/**
 * Graphic screen library.
 */
class Screen {
	static int width, height, sections;
	static boolean color;
	static int mapAddr;
	
    /** Initializes the Screen. */
    function void init() {
		let mapAddr = 16384;
		let width = 512;
		let height = 256;
		let sections = height * (width/16);
		let color = true;

		return;
    }

    /** Erases the whole screen. */
    function void clearScreen() {
		var int i;
		//let i = 0;
		while (i < sections) {
			do Memory.poke(mapAddr + i, 1+color);
			let i = i + 1;
		}
		return;
    }

    /** Sets the color to be used in further draw commands
     *  where white = false, black = true. */
    function void setColor(boolean b) {
		let color = b;
		return;
    }
	
	/** Checks if the given coordinates are inside the screen */ 
	function boolean validCoordinates(int x, int y) {
		if (((x < 0) | ~(x < width)) | ((y < 0) | ~(y < height))) {
			return false;
		}
		return true;
	}

    /** Draws the (x, y) pixel. */
    function void drawPixel(int x, int y) {
		var int section;
		if (~Screen.validCoordinates(x, y)) {
			do Sys.error(7); // Illegal pixel coordinates
		}
		
		let section = mapAddr+(y*32)+(x/16);
		if (color) {
			do Memory.poke(section, Memory.peek(section) | Math.twoToThe(x & 15));
		} else {
			do Memory.poke(section, Memory.peek(section) & ~Math.twoToThe(x & 15));
		}
		return;
    }

    /** Draws a line from (x1, y1) to (x2, y2) using Bresenhams line algorithm. */
    function void drawLine(int x1, int y1, int x2, int y2) {
		var int dx, dy; // distances between coordinates' components
		var int error, dError;
		var int remainder, remSum;
		var int absDx;
		
		var int temp;
		
		if (~Screen.validCoordinates(x1, y1)) {
			do Sys.error(8); // Illegal line coordinates
		}
		if (~Screen.validCoordinates(x2, y2)) {
			do Sys.error(8); // Illegal line coordinates
		}
		
		let dy = y2 - y1;
		// Check if we are able to use a specialised function
		if (dy = 0) {
			do Screen.drawHorizontalLine(x1, x2, y1);
			return;
		}
		
		let dx = x2 - x1;
		// Check if we are able to use a specialised function
		if (dx = 0) {
			do Screen.drawVerticalLine(y1, y2, x1);
			return;
		}
		
		// Swap starting points to ease logic
		if (x2 < x1) {
			let temp = x1;
			let x1 = x2;
			let x2 = temp;
			let temp = y1;
			let y1 = y2;
			let y2 = temp;
			let dy = y2 - y1;
		}
		
		let error = 0;
		let dError = Math.abs(dy/dx);
		let remainder = Math.remainder();
		let remSum = 0; // cumulative remainders from divisions
		let absDx = Math.abs(dx);
		
		while (~(x1 > x2)) {
			do Screen.drawPixel(x1, y1);
			let error = error + dError;
			let remSum = remSum + remainder;
			if (~(remSum < absDx)) {
				let error = error + 1;
				let remSum = remSum - absDx;
			}
			while ((error > 0) | ((error = 0) & ~((remSum + remSum) < absDx))) {
				do Screen.drawPixel(x1, y1);
				let y1 = y1 + Math.sign(dy);
				let error = error - 1;
			}
			let x1 = x1 + 1;
		}
		return;
    }
	/** Specialised draw function for vertical lines. To be only used by other draw
	  * functions */
	function void drawVerticalLine(int y1, int y2, int x) {
		var int startSection, section;
		
		if (y2 < y1) {
			let section = y1;
			let y1 = y2;
			let y2 = section;
		}
		
		let startSection = mapAddr + (y1*32) + (x/16);
		let section = 0;
		let x = Math.twoToThe(x & 15);
		
		while (~(y1 > y2)) {
			if (color) {
				do Memory.poke(startSection, Memory.peek(startSection) | x);
			} else {
				do Memory.poke(startSection, Memory.peek(startSection) & ~x);
			}
			let startSection = startSection + 32; // Move one row down
			let y1 = y1 + 1;
		}
		return;
	}
	
	/** Specialised draw function for horizontal lines. To be only used by other draw
	  * functions */
	function void drawHorizontalLine(int x1, int x2, int y) {
		var int startAddr, i;
		
		// Switch places to ease logic
		if (x2 < x1) {
			let i = x1;
			let x1 = x2;
			let x2 = i;
		}
		let startAddr = mapAddr + (y*32) + (x1/16);
		
		// Draw pixel by pixel until first full section
		let i = x1 & 15;
		while ((i < 16) & ~(x1 > x2)) {
			if(color) {
				let startAddr[0] = startAddr[0] | Math.twoToThe(i);
			} else {
				let startAddr[0] = startAddr[0] & ~Math.twoToThe(i);
			}
			let i = i + 1;
			let x1 = x1 + 1;
		}
		
		// Draw full 16 bit sections
		let startAddr = startAddr + 1;
		let i = x2 - 16;
		while (x1 < i) {
			let startAddr[0] = color;
			let x1 = x1 + 16;
			let startAddr = startAddr + 1;
		}
		
		// Draw the rest
		let i = x2 - x1;
		while (i > -1) {
			if(color) {
				let startAddr[0] = startAddr[0] | Math.twoToThe(i);
			} else {
				let startAddr[0] = startAddr[0] & ~Math.twoToThe(i);
			}
			let i = i - 1;
		}
		return;
	}

    /** Draws a filled rectangle where the top left corner
     *  is (x1, y1) and the bottom right corner is (x2, y2). */
    function void drawRectangle(int x1, int y1, int x2, int y2) {
		var int temp;
		if (~Screen.validCoordinates(x1, y1)) {
			do Sys.error(9); // Illegal rectangle coordinates
		}
		if (~Screen.validCoordinates(x2, y2)) {
			do Sys.error(9); // Illegal rectangle coordinates
		}
		
		if (y2 < y1) {
			let temp = y1;
			let y1 = y2;
			let y2 = temp;
		}
		while (~(y1 > y2)) {
			do Screen.drawHorizontalLine(x1, x2, y1);
			let y1 = y1 + 1;
		}
		return;
    }

    /** Draws a filled circle of radius r around (cx, cy) using Midpoint circle algorithm. */
    function void drawCircle(int cx, int cy, int r) {
		var int y, x, dOver2, yMinusX;
		
		if (r < 0) {
			do Sys.error(13); // Illegal radius
		}
		if (~Screen.validCoordinates(cx-r, cy-r)) {
			do Sys.error(12); // Illegal center coordinates
		}
		if (~Screen.validCoordinates(cx+r, cy+r)) {
			do Sys.error(12); // Illegal center coordinates
		}
		
		let dOver2 = 1 - r;
		let y = 0;
		let x = r;
		while (~(y > x)) {
			do Screen.drawHorizontalLine(x + cx, -x + cx, y + cy); // octants 1 to 4
			do Screen.drawHorizontalLine(y + cx, -y + cx, x + cy); // octants 2 to 3
			do Screen.drawHorizontalLine(-x + cx, x + cx, -y + cy); // octants 5 to 8
			do Screen.drawHorizontalLine(-y + cx, y + cx, -x + cy); // octants 6 to 7
			let y = y + 1;
			if (~(dOver2>0)) {
				let dOver2 = dOver2 + y + y + 1;
			} else {
				let x = x - 1;
				let yMinusX = y - x;
				let dOver2 = dOver2 + yMinusX + yMinusX + 1;
			}
		}
		return;
    }
}
